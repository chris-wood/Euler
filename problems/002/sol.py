# Problem 2. Each new term in the Fibonacci sequence is generated by adding the previous 
# two terms. By starting with 1 and 2, the first 10 terms will be:
#
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#
# By considering the terms in the Fibonacci sequence whose values do not exceed four 
# million, find the sum of the even-valued terms.

import sys

class L(object):
	""" This representation for L consists of a matrix product
		between a vector containing the (a,b) input pair and 
		a simple 2x2 matrix. This relationship is described below.
		
		By mathematical definition: 
		
			L(a,b) = (b, a+b)
			L^n(a,b) = (f(n;a,b),f(n+1;a,b))
		
		By matrix representation:
		
			L(a) = (0 1)(a) = (  b  )
			 (b)   (1 1)(b)   (a + b)
		
			L^n(a) = (0 1)^n(a) = ( f(n;a,b) )
			   (b)   (1 1)  (b)   (f(n+1;a,b))
	"""
	
	# The instance variables for the L object, consisting of the 
	# pair of elements a and b and the product matrix m.
	# The matrix is represented as a flat array/tuple.
	a = 0            # default to 0
	b = 0            # default to 0
	m = (1, 0, 0, 1) # default to identity matrix
	
	def __init__(self, a, b, v1, v2, v3, v4, valueLimit = -1):
		""" Constructor for L that initializes the (a,b) variables
			and the product matrix.
		"""
		self.a = a
		self.b = b
		self.m = (v1, v2, v3, v4)

	def power(self, p):
		""" Raise this object to the power p.
			
			This function utilizes one of the matrix power
			routines to calculate the power of the L object's 
			product matrix, and then performs the final matrix
			multiplication to find the resulting (a,b) tuple.
		"""
		matrix = matrixPowerOne(self.m, p)
		v1 = (matrix[0] * self.a) + (matrix[1] * self.b)
		v2 = (matrix[2] * self.a) + (matrix[3] * self.b)
		return (v1, v2)

def matrixProduct(m1, m2):
	""" Compute the product of two 2x2 matrices, where 
		each matrix is represented as a flat array/tuple.
	"""
	v1 = (m1[0] * m2[0]) + (m1[1] * m2[2])
	v2 = (m1[0] * m2[1]) + (m1[1] * m2[3])
	v3 = (m1[2] * m2[0]) + (m1[3] * m2[2])
	v4 = (m1[2] * m2[1]) + (m1[3] * m2[3])
	return (v1, v2, v3, v4)

def matrixPowerOne(base, p):
	""" Raise the object 'base' to the power p.
		
		This function implements the method of repeated
		squaring using a recursive approach to perform 
		exponentiation in O(logn) time.
	"""
	if (p == 0):
		return (1, 0, 0, 1) # Identity 
	elif (p == 1):
		return base
	elif ((p % 2) == 0):
		return matrixPowerOne(matrixProduct(base, base), p / 2)
	else:
		return matrixProduct(base, 
			matrixPowerOne(matrixProduct(base, base), (p - 1) / 2))

def matrixPowerTwo(base, p):
	""" Raise the object 'base' to the power p.
		
		This function implements the method of repeated
		squaring using an iterative based approach 
		to perform exponentiation in O(logn) time.
	"""
	# Initialize the product to the identity
	result = (1, 0, 0, 1)
	
	# Loop while the power is non-zero
	while (p != 0):
		
		# If the power is odd, multiply by the base 
		if ((p % 2) != 0):
			result = matrixProduct(result, base)
			p = p - 1
		
		# Square the base object and then cut the power in half 
		base = matrixProduct(base, base)
		p = p / 2

	# Return the resulting object 
	return result

def fibPow(n, a, b, valueLimit = -1):
	""" Implement L^{n}(a,b), which requires three parameters
		for n, a, and b. It returns a tuple (f(n;a,b), f(n+1;a,b)).
		
		This function utilizes the method of repeated
		squaring to raise an object of type L to the
		nth power and then return the first pair
		in L's evaluated tuple.
	"""
	base = L(a, b, 0, 1, 1, 1, valueLimit)
	return base.power(n)

def fibValueSum(n, modulus, valueLimit): # modulus is assumed to be >= 2
	ssum = 0
	a = 0
	b = 1
	c = a + b
	while (c < valueLimit):
		if (c % modulus == 0):
			ssum = ssum + c
		c = a + b
		a = b
		b = c
	return ssum

# This is the fixed upper bound used for autonomous testing
# of the fibPow function.
UPPER_BOUND = 100

""" Run the fibPow function.
	
	If the user enters a valid input, run it on that
	number, else run it with a pre-defined constant.
"""
if (len(sys.argv) == 4):
	# print fibPow(int(sys.argv[1]), 0, 1, int(sys.argv[2]))[0]
	print fibValueSum(int(sys.argv[1]), int(sys.argv[2]), int(sys.argv[3]))
elif (len(sys.argv) == 3):
	print fibPow(int(sys.argv[1]), 0, 1, int(sys.argv[2]))[0]
elif (len(sys.argv) == 2):
	print fibPow(int(sys.argv[1]), 0, 1)[0]
else:
	print fibPow(UPPER_BOUND, 0, 1)[0]

